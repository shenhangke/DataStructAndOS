//
// Created by MoonKnight on 2019/9/20.
//

#define CONST 1
#include "stdio.h"

String str="123";
/*
 *
 *
 *
批处理操作系统:一次性的将多个任务提交给计算机进行处理
分时操作系统:一次性的将多个任务提交给计算机
 实时操作系统:计算机系统能够及时的处理由过程控制反馈的数据

 进程:是应用程序在操作系统中运行的实体,是操作系统分配资源的最小单位

 PCB(process control block) 进程控制块.实际上在操作系统中就是一个结构体
 在这个结构体中,保存了一些与这个进程有关的信息:

 1.进程名
 2.进程的ID
 3.进程的上下文  *
 4.进程所需要的设备表
 ...

 因为在操作系统中,有很多的进程需要管理(操作系统可能同时创建很多的进程,因此,就会产生很多的进程控制块),操作系统会把
 进程控制块穿成一个链表,将这些块统一进行管理.
 当一个进程需要请求操作系统的某些资源的时候,进程首先会对操作系统发出请求,操作系统接收到请求之后,会将作出的更改记录到进程控制块中


 作业(job)
 JCB(job control block)作业控制块


 程序段:程序段是把一个进程所需要的所有指令,都放到一个连续的地址空间中,并且由操作系统记录下这一段的初始地址
 0f1f232 mov &10,&12  汇编指令
 00001110101  101  111

 数据段: (固定的常量,字符等)数据段会把在程序中定义的常量,显示定义的字符等看做是进程运行所需要的数据,将这个数据保存到进程
 内存空间的数据段中.

 IO缓冲设备:因为中央处理器的处理速度与外设的读取速度不一致,因此,需要使用一个缓冲设备,来将所有需要处理的数据进行缓冲,这个io缓冲设备
 一般是分层设备.

 作业一共会有这样的几个状态:
 1.提交状态:作业由输入设备进入外部存储器的过程.处于提交状态的作业,其信息正在进入系统(作业通过外部的输入设备输入,然后暂时存放在外部
 的存储设备上)
 2.后备状态: 当作业的全部信息进入到外存之后,系统,就为这个作业建立一个作业控制块(JCB)(系统就正式的承认了这个作业被生成了)
 3.执行状态:一个后备作业被作业调度程序选中,并分配了必要的资源进入了内存,作业调度程序同时为这个作业建立了相应的进程之后,这个作业就会由
 后备状态转到执行状态
 4.完成状态:当作业正常结束之后,他所占用的资源全部被系统收回时的状态

 Spooling:外部设备联机并行操作.提供让多种外围设备同时联机操作.本质上还是缓冲区的思想.首先通过中断将数据读入缓冲区,然后在核心设备需要数据的时候
 将数据从缓冲区读出
 这个技术的核心目的,是将独占的设备变成共享的设备



 内存申请分配算法:
 1.最先适应算法:从当前可用的地址空间开始分配,
 找到一块可以放得下这个作业的地址空间就结束,返回这个空间的首地址
 缺点:在低地址空间中,会造成可用的内存比较少,同时,空间碎片化严重


 2.最佳适应算法:从内存分区中,找到一块最能满足当前作业需求的最小空闲分区,
 返回这块分区的首地址
 优点:内存空间可以物尽其用
 缺点:会产生很多小块的内r内存碎片,导致之后如果有大的内存申请时,
 会找不到分配的空间


 3.最坏适应算法:扫描整个分区图,找到一块最大的分区给作业使用

 申请300k,申请100k,释放300k,申请150k,申请30k,
 申请40k,申请60k,释放30k,我的整个空闲的地址空间是512K.
 缺点:使得存储器中大片的连续存储区域变少


临界区:临界区就是每个进程中访问临界资源的程序段
 临界区是由属于不同并发进程的程序段共享使用数据或者共用的数据变量引起的.

段式管理:
code:0x00000000
data:0x0000034f

code:
0x0000000-0x000000015   11  1f 2f ff 35 ....
0x00000016-....


data:
0x0000034f-0x000....

系统将程序按照内容或者过程分成段,每一段都有自己的名字,用户程序的地址空间是二维的(由段号和段内地址组成,段的大小是不固定的,每一
 段的大小都可以不一样).系统以段为单位来分配内存,通过地址映射机构,将虚拟地址转换成实际的物理地址,多个进程可以通过段名来实现子程序的
 共享.,通过段名+便宜地址来实现一个共同子程序的共享

 文件存取(读和写)  文件存取的三种方法
 1.顺序存取:读操作总是读出上一次文件读取的末尾
           |
 010101010101010101010000011111

 2.直接存取.将所有的内存,划分成多个部分,然后每一个部分都进行一个编号,使用编号直接找到需要读取的内存块

 3.索引存放.文件存放的位置不是按照顺序进行存储.而是按照文件的特征,存放的位置等信息编码成主键,然后对主键创建索引,使用索引去
 寻找要找的文件

 hash值 文件存放的地址


 操作系统如何管理和使用设备
 在现代的操作系统中,设备要供所有的进程使用,每一个进程要使用的设备由操作系统同一分配
 分配可能会涉及到一些数据结构,有以下几项:
 1.DCT(设备控制表):记录设备的一些情况(比如说,这个设备当前是不是空闲,有没有分配给哪一个进程使用,是否使用完毕)
 2.COCT(控制器控制表):系统为每一个控制器都设置了一张用于记录本控制之气情况的控制器控制表
 3.CHCT(通道控制表).记录了通道的情况,比如(这个表所标记的这个通道是不是畅通,当前通道是忙碌状态还是闲状态等)
 4.SDT(系统设备表),在这个表中,记录了当前系统中有那些设备是可以用的

 一个进程要使用一个设备需要经历如下的几个过程:
 1.进程向系统提出I/O请求,表明,我现在需要使用外部的设备
 2.系统首先会到SDT这个表中,去请求对应设备的DCT表,从DCT这个表中去了解这个设备当前是不是可以用的.如果这个设备当前正在被使用,
 那么就把这个请求挂起在进程的PCB中,如果设备是可用的,系统就会到设备的DCT表中,去查找与控制这个设备的控制器的COCT
 3.通过这个COAT表查看当前这个控制器是不是忙碌,是不是被占用,如果当前的控制器无法使用,那么会将请求控制器的这个请求,挂载在PCB上
 4.如果查看COCT之后,发现这个控制器是可用的,那么就会从COCT表中去查找对应的通道控制表(CHCT),
 5.在CHCT中,查看当前的这个通道是不是忙碌,是不是被阻塞,如果有问题的话,会被挂起在请求进程的PCB中
 6.如果通道当前也是可以用的,那么系统就会把通道,控制器,设备分配给这个进程,这个进程就可以与这个设备进行通信
 (如果其中有任何一步发现设备正忙,都会把请求挂载在请求进程的PCB上面,等到设备可用,进程会从PCB中拿到这个请求,然后从之前中断的步骤
 处开始执行)


 死锁:
 死锁:A进程等待一个资源才可以运行,但是这个资源被B占用了,但是同时,这个B进程被阻塞了,那么A进程就会永远的等着而不能进行

 A,B两个进程都需要同时拥有C,D资源才可以运行.但是发生了这样的一个情况(只有当一个进程运行完成之后,才会释放他所占用的资源)

 A进程拿到了资源C,B进程同时拿到了资源D   死锁

 死锁发生的条件:
 1.互斥.一次只有一个进程可以使用一个资源,其他进程不能访问已经分配给其他进程的资源
 2.占有且等待:一个进程在等待分配得到其他的资源的时候,会持续的占有资源
 3.非抢占:进程不能抢占其他进程中已经占有的资源

 死锁的预防:
 死锁的预防,实际上,就是去破坏上面死锁发生的条件
 1.互斥.互斥这个问题是没有办法解决的.如果操作系统,支持互斥的化,那么互斥这个条件就一定是会发生的.
 2.占有且等待.要求进程在请求资源的时候,要一次性的请求所有的资源,如果所有的资源中有任何一个资源没有被申请到,那么就等待,等到
 所有的资源都申请到了再执行
 3.非抢占: 一个进程如果申请其他的资源被拒绝了,那么他必须释放他当前占有的资源
 4.循环等待.给资源排序,如果一个进程占有了一个资源,那么他要申请的资源只能排在这个资源的后面
 C  D


 内存的请求和换页

 我们的内存为了便于管理,实际上我们会将整个的内存空间进行分页
 页:1024BYTE作为一个页
 我们把进程所要使用的内容,进程的数据,代码等进行分页,然后,根据需要放到内存中去执行.
 通常来说,由于内存的大小往往要小于外存的大小,并且,在实时操作系统中,可能会出现内存中保存多个进程信息的情况
 那么会导致内存不够用.设计操作系统的人,就想出了换页这种动态的算法来解决这个问题

 最佳替换算法(OPT):替换下次访问距离当前时间最长的页,这个算法需要操作系统知道将来可能发生的事件,但是
 这是显然不可能的,所以,这种算法,只能作为衡量其他算法的标准

 最近最少使用算法(LRU):替换上次使用距离当前最远的页.替换最近最不可能被访问到的页.性能跟OPT差不多,但是很难实现

 先进先出算法(FIFO):将页面看做一个循环缓冲区,按循环的方式替换.这种实现的方式是最简单的.里面的逻辑其实就是换出在内存中驻留时间
 最长的页面.但是由于一部分的程序或者数据需要被频繁的访问到,如果用这种算法的话,会导致访问这些需要被频繁访问的数据的时候换页次数会
 增多
 算法的换页频度就会很高,导致时间花费就会很高

 Clock时钟替换算法:给每一个也关联一个使用位.当这个页被第一次装到内存或者被重新访问到的时候,将使用位置为1.在每一次需要替换的时候
 ,查找使用位为0的第一个帧进行替换,在扫描过程中,如果碰到使用位为1的帧,那么就将使用位置为0,在继续扫描,如果所有的帧的使用位都为0,那么就
 替换第一个帧
 这种算法的话,他的换页次数仅次于FIFO算法


 信号量
 两个或者多个进程可以通过简单的信号进行合作.一个进程可以被迫在某一个位置停止.知道它接收到了一个特定的信号.
 任何复杂的合作需求,都可以通过适当的信号结构得到满足.为了发信号,需要使用一个称为信号量的特殊变量.
 为了通过信号量s发送信号,可以执行原语semSignal(s)(V来进行表示)和接收 信号的原语semWait(s)(通过这个用P来表示),我们通常也会直接使用P,V来代替这
 两个函数名使用

 我们可以把信号量看做是一个具有整数数值的变量.在它之上有三种操作

 1.一个信号量,可以被初始化为负数
 2.semWait操作(也就是P操作),可以使得信号量减1,如果信号量的数值变成负数,那么执行P操作的进程被阻塞.否则进程就继续执行
 3.执行semSignal(V),可以使得信号量加1,如果信号量的值小于或者等于0,那么被P操作阻塞的进程就会被接触阻塞

 P(s)
 V(s)

 如果我的共享资源可以同时被三个进程使用

 我的信号量就可以初始化为3...

 apple=3
有三个人要去吃这个苹果

 每一个人吃之前,都需要执行一个P(apple)操作,去检查当前果盘里还有没有苹果

 二元信号量
 对应有三种操作
 1.信号量的取值,只可以初始化为0或者1
 2.P操作会检查信号量的值,如果值为0,那么进程就会被阻塞,不会往下面执行,如果检查值为1,那么P操作会把信号量的值变成0,然后执行
 下面的操作
 3.V操作会检查是不是有进程在当前这个信号量上面被阻塞,如果发现有进程被阻塞到当前的信号量上,那么受阻塞的进程就会被唤醒,如果没有
 任何进程受阻,那么V操作,就会把信号量置1

 多道程序设计:
 通常意义上来说,可以允许多个作业或者进程同时运行的操作系统,就可以说这个操作系统支持多道程序设计
 多道程序设计的定义是指,在内存中同时放若干的程序,让他们在系统中并发的执行.共享系统中的各种资源.当一道程序暂停执行的时候,
 CPU就转而去执行另外的进程
 我们引入了多道程序设计这个概念之后,就可以使得操作系统在宏观上是并行的,在微观上是串行的(通过一个特别快的时间片来进行切换)
 多道程序设计的好处在于:1.提高CPU的利用率
                        2.提高内存和IO设备的利用率
                        3.增加系统的吞吐量
由于多道程序设计要把所有的进程都放到内存中,因此,多道程序设计需要有足够的内存作为支持才可以运作

















*/


int i=1;

void changeGlobal(){
    {
        i+=1;
        printf("%d",i);
    }
}

int empty1=1;
int empty2=1;
int full1=0;
int full2=0;




