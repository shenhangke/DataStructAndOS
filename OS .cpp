//
// Created by MoonKnight on 2019/9/20.
//

#define CONST 1
#include "stdio.h"

String str="123";
/*
 *
 *
 *
批处理操作系统:一次性的将多个任务提交给计算机进行处理
分时操作系统:一次性的将多个任务提交给计算机
 实时操作系统:计算机系统能够及时的处理由过程控制反馈的数据

 进程:是应用程序在操作系统中运行的实体,是操作系统分配资源的最小单位

 PCB(process control block) 进程控制块.实际上在操作系统中就是一个结构体
 在这个结构体中,保存了一些与这个进程有关的信息:

 1.进程名
 2.进程的ID
 3.进程的上下文  *
 4.进程所需要的设备表
 ...

 因为在操作系统中,有很多的进程需要管理(操作系统可能同时创建很多的进程,因此,就会产生很多的进程控制块),操作系统会把
 进程控制块穿成一个链表,将这些块统一进行管理.
 当一个进程需要请求操作系统的某些资源的时候,进程首先会对操作系统发出请求,操作系统接收到请求之后,会将作出的更改记录到进程控制块中


 作业(job)
 JCB(job control block)作业控制块


 程序段:程序段是把一个进程所需要的所有指令,都放到一个连续的地址空间中,并且由操作系统记录下这一段的初始地址
 0f1f232 mov &10,&12  汇编指令
 00001110101  101  111

 数据段: (固定的常量,字符等)数据段会把在程序中定义的常量,显示定义的字符等看做是进程运行所需要的数据,将这个数据保存到进程
 内存空间的数据段中.

 IO缓冲设备:因为中央处理器的处理速度与外设的读取速度不一致,因此,需要使用一个缓冲设备,来将所有需要处理的数据进行缓冲,这个io缓冲设备
 一般是分层设备.

 作业一共会有这样的几个状态:
 1.提交状态:作业由输入设备进入外部存储器的过程.处于提交状态的作业,其信息正在进入系统(作业通过外部的输入设备输入,然后暂时存放在外部
 的存储设备上)
 2.后备状态: 当作业的全部信息进入到外存之后,系统,就为这个作业建立一个作业控制块(JCB)(系统就正式的承认了这个作业被生成了)
 3.执行状态:一个后备作业被作业调度程序选中,并分配了必要的资源进入了内存,作业调度程序同时为这个作业建立了相应的进程之后,这个作业就会由
 后备状态转到执行状态
 4.完成状态:当作业正常结束之后,他所占用的资源全部被系统收回时的状态

 Spooling:外部设备联机并行操作.提供让多种外围设备同时联机操作.本质上还是缓冲区的思想.首先通过中断将数据读入缓冲区,然后在核心设备需要数据的时候
 将数据从缓冲区读出
 这个技术的核心目的,是将独占的设备变成共享的设备



 内存申请分配算法:
 1.最先适应算法:从当前可用的地址空间开始分配,
 找到一块可以放得下这个作业的地址空间就结束,返回这个空间的首地址
 缺点:在低地址空间中,会造成可用的内存比较少,同时,空间碎片化严重


 2.最佳适应算法:从内存分区中,找到一块最能满足当前作业需求的最小空闲分区,
 返回这块分区的首地址
 优点:内存空间可以物尽其用
 缺点:会产生很多小块的内r内存碎片,导致之后如果有大的内存申请时,
 会找不到分配的空间


 3.最坏适应算法:扫描整个分区图,找到一块最大的分区给作业使用

 申请300k,申请100k,释放300k,申请150k,申请30k,
 申请40k,申请60k,释放30k,我的整个空闲的地址空间是512K.
 缺点:使得存储器中大片的连续存储区域变少


临界区:临界区就是每个进程中访问临界资源的程序段
 临界区是由属于不同并发进程的程序段共享使用数据或者共用的数据变量引起的.



*/


int i=1;

void changeGlobal(){
    {
        i+=1;
        printf("%d",i);
    }
}

