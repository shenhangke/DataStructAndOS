//
// Created by MoonKnight on 2019/9/5.
//

/*
 * 排序:
 * 排序的本质,就是把一些无序的序列,变成有序的序列的过程
 *
 * 排序的稳定性:
 * 我选用一种排序的方法,如果在排序的中间结果中,对于相同的输入,每一次的中间结果都是一样的,那么我们就说这种排序的方法是稳定
 * 的排序方法,反之,就是不稳定的排序方法
 *
 * 内排序和外排序:
 * 所谓的内排序,就是在排序的过程中,所有的记录都被放置在内存中,如果因为排序的记录数(或者是中间结果很多),需要借助外部的存储
 * 那么这样的排序方法就叫做内排序
 *
 * 对于排序算法来说,我们需要考虑的因素有以下几种:
 * 1.时间的复杂度(算法执行的时间长短)
 * 2.辅助空间
 * 3.算法的复杂性
 *
 * 内排序有以下几个:
 * 插入排序
 * 交换排序
 * 选择排序
 * 归并排序
 *
 *
 *
 * 1.冒泡排序O(n^2)
 * 冒泡排序.实质上是一种交换排序
 * PS:所谓的交换排序,就是只用交换序列中的元素位置,而不用将元素拿出来或者放进去这样的操作的排序,就叫做交换排序
 *
 * 比如说,我们现在有这样的一个序列
 * {9,1,5,8,3,7,4,6,2}
 *
 * 我现在要把这个无序的序列进行排序,使得里面的数从小到大排列
 * 设置两个值,用来记录我当前交换到哪一个元素了
 * 这两个值我记做i=0,j=i+1
 *
 * i+1=2
 * j=1
 * {1,5,8,3,7,4,6,2,9}
 *
 * for(int i=0;i<n;i++){
 *      for(int j=i;j<n;j++){
 *
 *      }
 * }
 *
 * 简单选择排序:O(n^2)
 * 通过将当前元素通过n-i次比较,然后从n-i+1个记录中选出关键字最小的记录,并且和第i个交换
 *
 * {9,1,5,8,3,7,4,6,2}
 *
 * 第一趟,比较了n-1,选出最小的数(I表示的是第几趟)
 * {1,9,5,8,3,7,4,6,2}
 *
 * 第二趟的时候,就不用考虑第一个元素,我需要比较的就是n-2
 * {1,2,5,8,3,7,4,6,9}
 *
 * 直接插入排序:O(n^2)
 * 我每一次选择一个数,将这个数放到一个已经排好序的序列中,并且我再放的时候要保证我放的是有序的
 * {9,1,5,8,3,7,4,6,2}
 * 一开始的时候,我的已经拍好序的序列是空的
 * {9}
 * {1,9}
 * {1,5,9}
 * {1,5,8,9}
 * ...
 *
 * 内排序:
 * {9,1,5,8,3,7,4,6,2}
 * i=2
 * {1,9,5,8,3,7,4,6,2}
 *
 * for (int j=0;j<i;j++){
 *
 * }
 * i=3
 * {1,5,9,8,3,7,4,6,2}
 *
 * 希尔排序:O(NlogN)
 * {9,1,5,8,3,7,4,6,2}
 *
 * 给定一个步长
 * 比如说,我给定的步长为3
 *
 * 9 8 4
 * 1 3 6
 * 5 7 2
 *
 * 我使用步长,将整个序列进行分组之后,将每一组的序列进行直接插入排序
 * 4  8  9
 * 1  3  6
 * 2  5  7
 *
 * 然后我再将这几个数进行合并
 *
 * 4 1 2 8 3 5 9 6 7
 *
 * 下一次,我缩短步长,是步长为原来的一般 step=step/2
 *
 * step = 1
 *
 * 4
 * 1
 * 2
 * 8
 * 3
 * 5
 * 9
 * 6
 * 7
 *
 *  若对序列(tang,deng,an,wan,shi,bau,fang,liu)按字典序进行排序,初始步长为4的希尔排序第一趟的结果为:
 *
 *
 *  1希尔排序 首先使用步长,将所有的序列进行分组
 *  2然后把每一组中的序列进行排序
 *  3排序完成之后进行合并
 *  4将步长缩小为原来的一半
 *  5 重复1,2,3,4 直到步长为1进行一次排序之后,算法结束
 *
 *
 *  堆排序:
 *  首先,什么是大顶堆和小顶堆
 *  堆实质上就是一个完全二叉树,在这个完全二叉树中,所有根节点的值,都大于其子节点,那么这样的树我们就称为大顶堆
 *  反之,                                                        都小于其子节点,那么这样的树,我们就称为小顶堆
 *  大顶堆的特性:
 *  1.这个树必须是一个完全二叉树
 *  2.这个树中的节点一定满足根节点比子节点大/小
 *
 *  排序二叉树:不用是一个完全二叉树,每一个节点的左子节点都小于根节点,右子节点都大于根节点
 *  大/小顶堆来说,首先是一个完全二叉树,子节点要么都比父节点小,要么都比父节点大
 *
 *  构建:
 *  1.我们每一次添加节点,都从叶子节点开始添加(添加的原则是添加完成节点之后,剩下的树需要满足完全二叉树的条件)
 *  2.在添加完节点之后,我们需要比较当前添加的这个节点与他的根节点谁大,如果当前的这个节点更大的话,需要把这个节点进行上浮
 *  (也就是把这个节点的位置与他的父节点进行互换)
 *  3.接着,重复第2步,直到不需要满足父节点的值比子节点大为止
 *
 *  如何用一个大顶堆来进行排序:
 *  1.先把根节点弹出去,然后记录这个根节点
 *  2.把完全二叉树中编码最大的那个节点抬到整颗树的根节点上面来
 *  3.看现在的这个二叉树是不是一个大/小顶堆,如果不是的话,对比当前的这个节点的两个子节点谁大
 *  4.选择大的那个节点,与当前的根节点进行互换
 *  5.重复3,4 步,直到整棵树是一个大顶堆(大顶堆是一个完全二叉树)
 *  6,重复1,2,3,4,5步,直到最后所有的节点都被弹出去,那么算法结束
 *  7.弹出去的节点的顺序,就是排好序的序列
 *
 *  如果是大顶堆的话,那么序列就是从大到小
 *  如果是小顶堆的话那么序列就是从小到大
 *
 *  归并排序:
 *
 *  归并排序,是先把所有的序列分成一个一个的数字,然后,对这个数字进行两两排序,
 *  排好之后再进行一次合并,将合并完成的序列再一次进行排序,依次类推
 *  知道最后合并的序列中包括了所有的元素为止.
 * */