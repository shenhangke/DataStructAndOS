//
// Created by MoonKnight on 2019/8/29.
//

/*
 * 图:
 *
 * 定义:
 * 每一个节点叫做顶点,通常顶点用v来表示.对于所有顶点的集合,我们使用一个大写的V来表示,vetex
 * V={v1,v2,v3....}
 * 对于图中的边,我们通常使用e来进行表示,对于所有边的集合,我们使用E来进行表示 edge
 *
 *对于图来说,其中的边是有可能有方向,也有可能是没有方向.
 * 对于图中所有边都有方向的图,叫做有向图,
 * 如果图中所有的边都没有方向,这种图叫做无向图
 *
 * 如果我们可以用一条路径,走过图中的每一个顶点,那么这样的图就叫做连通图
 * 除外的图,就叫做非连通图
 *
 * 如果图中的边的数目远远大于顶点的数目,我们就叫这种图为稠密图
 * 反之,就叫做稀疏图
 *
 * 对于有向图来说,因为有向图顶线之间是通过有方向的边进行相连的.
 *
 * 度:对于一个有向图的顶点来说,如果有一个箭头的箭头方向指向这个顶点,那么我们就把这个顶点的入度+1
 * 最后的结果,就是这个顶点的入度
 * 反之,就是计算出度
 *
 * 环 不管是有向图还是无向图(如果是有向图的话,就是只能顺着箭头的方向走),我们从任意一个顶点出发,
 * 经过某条路径,可以回到这个顶点,那么我们就说这个图中存在  环
 *
 * 图在数据结构中怎么存储
 *
 * 在图中,我们如果要存储一个图的话,有两种方法
 *1.我们使用一个二维数组,来存储图中的边和顶点
 * 2.我们使用链式结构,搭配一个一维数组来存储这个图
 *
 * 1.我们如何用一个二维数组来进行存储
 *
 *    A  B  C  D  E
 * A  0  0  10   0  0
 * B  0  0  5   0  0
 * C  10  5  0   0  1
 * D  0  0  0   0  1
 * E  0  0  1  1   0
 *
 * 对于无向图来说,他的存储矩阵,是一个斜轴对称的矩阵
 * 这种存储方式,叫做这个图的邻接矩阵
 *
 * 有时候,对于一个图来说,边是可能有权值的
 * 如果遇到这种带权值的路径的话,那么邻接矩阵中的相应的值也发生改变
 *
 *
 * 对于有向图来说,与无向图的邻接矩阵不一样的地方在于
 *
 * 2.邻接链表
 * 我们用一个一维数组来存储图中的所有节点(这中存储可以是无序的)
 *其中,我构建一个节点块,每一个节点块都存放在这个数组中,节点块中我们放一个指针,指向所有与这个节点直接
 * 相连的节点
 *
 * 图的遍历
 * 1.深度优先搜索(DFS)
 *
 * 我先顺着一条道走到黑,走到无法再走的时候,我们就需要退回到前一个有分叉的点
 * 从前一个有分叉的点选择另外一条还没有走过的分叉,去走一下试试看
 *
 * 如果我们要使用这个方法的话,我们在代码中,会使用递归的方式来进行执行
 *
 *
 * 2.广度优先搜索(BFS)
 *顺着一个点一个点的去记录这个点的所有可能性,将这个点的所有可能性都排除完了之后
 * 我们就从队中删去这个点,开始考察队中的下一个点
 *
 * 对于这个方法,我们使用队这个结构,来进行执行
 *
 *
 * 图的最小生成树
 * 我们需要找到一个图,这个图是原来图的一个子图
 * 这个图有一些特征
 * 1.这个图中包含了所有原图中的节点
 * 2.这个图中,我们要用最少的边去连通所有的顶点
 * 3.如果边是有权值的话,那么这个图中的权值总和,一定是最小的
 * 4.这个图的本质还是一个连通图
 * 5.但是最小生成树也可以被看做是一颗树
 *
 * 我们怎么去构建这样的一颗树呢?
 * 1.普利姆算法(prime)
 *  首先,我们设定一个顶点集合,V,在算法一开始的时候,这个顶点集合是空的
 *  V={},E={}
 *  在所有的顶点中,我们任意选择一个顶点,然后将这个顶点纳入到集合V中,然后找到与
 *  这个顶点相连的权值最小的一条边,将这条边的另一端的顶点,也放到集合V中
 *  如果碰到环路,就去次小的权值边
 *
 *  一直到所有的顶点都被纳入到这个顶点集合中,结束
 *
 *  如果在一个图中,边的数组远远大于点的数目,我们就要使用prime算法,反之,就用kruskal算法
 *
 *
 *  2.克鲁斯卡尔算法(Kruskal)
 *  1,我们把所有的点都选到点集中,每一个点,都看做是一个独立的树
 *  然后从小到大,依次选择权值最小的边
 *  选择的依据为:
 *  1.这条边的权值要是当前没有被选过的边中最小的
 *  2.这条边要可以连接两个不一样的树
 *
 * (所有被连接起来的点,都可以看做是一颗完整的树)
 *
 *
 * */


typedef struct NODE{
    char name;
    struct NODE* next;
    int len;
}Node,*PNode;


Node a,b,c,d,e;
Node list[5]={a,b,c,d,e};

void walk(PNode current){
    if (/*这个节点我还没有走过*/){
        record(current);
        for(int i=0;i<current->len;i++){
            walk(current->next);
        }
    }else{
        return;
    }
}

//我们把每个节点都用指针串起来
