//
// Created by MoonKnight on 2019/8/29.
//

/*
 * 图:
 *
 * 定义:
 * 每一个节点叫做顶点,通常顶点用v来表示.对于所有顶点的集合,我们使用一个大写的V来表示,vetex
 * V={v1,v2,v3....}
 * 对于图中的边,我们通常使用e来进行表示,对于所有边的集合,我们使用E来进行表示 edge
 *
 *对于图来说,其中的边是有可能有方向,也有可能是没有方向.
 * 对于图中所有边都有方向的图,叫做有向图,
 * 如果图中所有的边都没有方向,这种图叫做无向图
 *
 * 如果我们可以用一条路径,走过图中的每一个顶点,那么这样的图就叫做连通图
 * 除外的图,就叫做非连通图
 *
 * 如果图中的边的数目远远大于顶点的数目,我们就叫这种图为稠密图
 * 反之,就叫做稀疏图
 *
 * 对于有向图来说,因为有向图顶线之间是通过有方向的边进行相连的.
 *
 * 度:对于一个有向图的顶点来说,如果有一个箭头的箭头方向指向这个顶点,那么我们就把这个顶点的入度+1
 * 最后的结果,就是这个顶点的入度
 * 反之,就是计算出度
 *
 * 环 不管是有向图还是无向图(如果是有向图的话,就是只能顺着箭头的方向走),我们从任意一个顶点出发,
 * 经过某条路径,可以回到这个顶点,那么我们就说这个图中存在  环
 *
 * 图在数据结构中怎么存储
 *
 * 在图中,我们如果要存储一个图的话,有两种方法
 *1.我们使用一个二维数组,来存储图中的边和顶点
 * 2.我们使用链式结构,搭配一个一维数组来存储这个图
 *
 * 1.我们如何用一个二维数组来进行存储
 *
 *    A  B  C  D  E
 * A  0  0  10   0  0
 * B  0  0  5   0  0
 * C  10  5  0   0  1
 * D  0  0  0   0  1
 * E  0  0  1  1   0
 *
 * 对于无向图来说,他的存储矩阵,是一个斜轴对称的矩阵
 * 这种存储方式,叫做这个图的邻接矩阵
 *
 * 有时候,对于一个图来说,边是可能有权值的
 * 如果遇到这种带权值的路径的话,那么邻接矩阵中的相应的值也发生改变
 *
 *
 * 对于有向图来说,与无向图的邻接矩阵不一样的地方在于
 *
 * 2.邻接链表
 * 我们用一个一维数组来存储图中的所有节点(这中存储可以是无序的)
 *其中,我构建一个节点块,每一个节点块都存放在这个数组中,节点块中我们放一个指针,指向所有与这个节点直接
 * 相连的节点
 *
 * 图的遍历
 * 1.深度优先搜索(DFS)
 *
 * 我先顺着一条道走到黑,走到无法再走的时候,我们就需要退回到前一个有分叉的点
 * 从前一个有分叉的点选择另外一条还没有走过的分叉,去走一下试试看
 *
 * 如果我们要使用这个方法的话,我们在代码中,会使用递归的方式来进行执行
 *
 *
 * 2.广度优先搜索(BFS)
 *顺着一个点一个点的去记录这个点的所有可能性,将这个点的所有可能性都排除完了之后
 * 我们就从队中删去这个点,开始考察队中的下一个点
 *
 * 对于这个方法,我们使用队这个结构,来进行执行
 *
 *
 * 图的最小生成树
 * 我们需要找到一个图,这个图是原来图的一个子图
 * 这个图有一些特征
 * 1.这个图中包含了所有原图中的节点
 * 2.这个图中,我们要用最少的边去连通所有的顶点
 * 3.如果边是有权值的话,那么这个图中的权值总和,一定是最小的
 * 4.这个图的本质还是一个连通图
 * 5.但是最小生成树也可以被看做是一颗树
 *
 * 我们怎么去构建这样的一颗树呢?
 * 1.普利姆算法(prime)
 *  首先,我们设定一个顶点集合,V,在算法一开始的时候,这个顶点集合是空的
 *  V={},E={}
 *  在所有的顶点中,我们任意选择一个顶点,然后将这个顶点纳入到集合V中,然后找到与
 *  这个顶点相连的权值最小的一条边,将这条边的另一端的顶点,也放到集合V中
 *  如果碰到环路,就去次小的权值边
 *
 *  一直到所有的顶点都被纳入到这个顶点集合中,结束
 *
 *  如果在一个图中,边的数组远远大于点的数目,我们就要使用prime算法,反之,就用kruskal算法
 *
 *
 *  2.克鲁斯卡尔算法(Kruskal)
 *  1,我们把所有的点都选到点集中,每一个点,都看做是一个独立的树
 *  然后从小到大,依次选择权值最小的边
 *  选择的依据为:
 *  1.这条边的权值要是当前没有被选过的边中最小的
 *  2.这条边要可以连接两个不一样的树
 *
 * (所有被连接起来的点,都可以看做是一颗完整的树)
 *
 *  最短路径
 *  找到图中两个点之间的最短路径
 *
 *  1.迪杰斯特拉算法(dijkstra)
 *   这个是一个贪心算法,在这个算法中,每一次都去找距离当前这个顶点最短的路径,存入表中
 *   然后在找后面的顶点距离时,要使用前面顶点已经计算好的距离.
 *
 *   在填表的过程中,还需要另外一个数组,来记录每一个节点的前驱节点(就是我是从哪个节点走过来的)
 *   根据这个数组,就可以得到整个全局的最短路径
 *
 *   这个算法的时间复杂度
 *
 *   O(n^3)
 *
 *  2.弗洛伊德算法(floyd)
 *
 *  这个短发的时间复杂度也是O(n^3),但是这个算法的好处在于,代码很简洁
 *  这个算法的本质,是用两个矩阵(两个二维数组),来存储中转节点的信息
 *
 *  1.先看矩阵的列序,找出所有通过第一个节点到达另外一个顶点的最短路径
 *  2.然后求出之后,更新D和P矩阵,得出结果
 *
 *  拓扑排序
 *  1.先找到图中入度为0的顶点,将这个顶点从图中删掉
 *  2.记录这个顶点
 *  3.同时,删掉以这个顶点为尾的弧
 *  4.重复第1,2,3,直到图中,没有入度为0的点,或者剩下的图是一个空图时,循环结束
 *
 *
 * 关键路径
 * 关键路径是基于拓扑排序的基础上构建的
 * 如何求关键路径:
 *
 *
 * 有两个时间是需要关注的:
 * 1.最早开始时间
 * 2.最晚开始时间
 *
 * 我现在有两个任务,一个是做老师布置的作业,需要2个小时
 * 另外一个是做家长布置的作业,也是2个小时
 * 我的总可用时间是4个小时
 *
 * 因为老师布置的作业比较关键,或者说优先级比较高,因此我必须先做老师布置的
 *
 * 那么最早开始时间,是0
 *
 * 那么最晚开始的时间,也是0
 *
 * 所谓的关键活动,就是最早发生时间和最晚发生时间是一样的
 *
 * 要求这样的一个关键路径,我们需要做两个循环,一个准备工作
 * 准备工作是:
 *  使用之前的求拓扑路径的方法,把这个图的拓扑序列求出来
 *  然后在这个拓扑序列的基础上,求出每一个点的最早发生时间
 *  然后,同样的,在这个拓扑排序的基础上,求出每一个点的最晚发生时间
 *  对于两个时间,如果其中点的最早发生时间与最晚发生时间一致,那么我们就说
 *  这个活动,是关键活动
 *
 *  求最早开始时间,使用的算法,类比最短路径算法,
 *  从顶点开始,依次去求出距离当前这个顶点最远的距离是多少
 *  把最远的距离作为当前节点的最早开始时间,进行记录
 *
 * */


typedef struct NODE{
    char name;
    struct NODE* next;
    int len;
}Node,*PNode;


Node a,b,c,d,e;
Node list[5]={a,b,c,d,e};

void walk(PNode current){
    if (/*这个节点我还没有走过*/){
        record(current);
        for(int i=0;i<current->len;i++){
            walk(current->next);
        }
    }else{
        return;
    }
}

//我们把每个节点都用指针串起来
