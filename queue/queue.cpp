//
// Created by 沈航可 on 2019-08-23.
//

/*
 * 队列满的条件是
 * (rear+1)%queueSize==?front
 * 计算队列长度的公式：
 * (rear-front+queueSize)%queueSize
 * */



/*
 * 栈的结构，是只能在线性表的一头进行插入和删除操作
 * 相对应的操作就是pop,和push
 *
 *
 * 队列的本质，也是线性表，我们对这个表进行操作的时候，只能在这个表的一头进行插入操作，另外一头，进行删除操作
 * 0  1   2   3   4
 * ------------------------
 * 1 | 2| 3| 4|5|
 * ------------------------
 * 我们暂时使用顺序结构来进行说明
 *
 *
 * 1 2 3 4 5
 *
 * 如果我们现在要删除一个数据，只能够删除5，因为5这个元素，是在这个线性表的最尾端
 * 如果我们要插入一个元素，我们只能把这个元素插入到线性表的开头，也就是1的前面
 *
 * 8这个元素插入到这个队列中
 * 8 1 2 3 4 5
 *
 * 如果我要删除一个元素从线性表中删除一个元素，我只能删除5
 *
 *
 * 对应对栈的pop和push操作，队列中也有相应的操作
 * 分别叫做，出队，和入队
 *
 *
 **/


int arr[10];   //令这个数组就是一个队列

//所以我需要定义两个指针，一个指向队头，一个指向队尾

int front,rear;

void initQueue(){
    front=0;
    rear=0;
}

/*
        front
          |
-------------
 5|2 | 1 | 8| 5|2|1|8
-------------
                 |
               rear

 如果我们要插入一个元素，我们就保持头指针不变，在尾指针指向的地址处，填入元素，然后让尾指针加1
 如果我要进行删除操作，那么我们就保持尾指针不变，让头指针+1

 那么在这种情况下，队列的长度，就是rear-front

 在一般队列中，队列长度的计算方法是
 rear-front
 判断一个队列是不是为空，只需要判断
  front?=rear


 还有一种队列，叫做循环队列
   跟一般的队列结构不同的地方在于，如果我添加元素到了数组的末尾，想要再添加元素（在队列还可以添加元素的时候，就是说我申请的这个数组只中前面
   部分还有空余）的时候，我可以将尾指针，指向这个数据的开头元素，从数据开头的元素开始重新使用

   在这种操作情况下，
   队列为空的时候，头尾指针是相等的，但是当队列满了的时候，头尾指针也是相等的

   那么，我们就需要解决，怎么判断这个队列是空的还是满的

   4/3=1。。。1

   5%4=1

   在循环队列中，rear这个指针，有可能在front指针的前面，也有可能在他的后面

   循环d队列满的条件是
  (rear+1)%queueSize==?front

  计算队列的长度
 * (rear-front+queueSize)%queueSize
 *
 * 队列的链结构
 *
 *        front
 *          |
node_2->node_3->new_node
 *                    |
 *                   rear
 *
 *  我要在这个队列中，插入元素
 *  1。把rear指向的这个节点的后继指针指向我要创建的新节点
 *  2.把尾指针，指向新节点
 *
 *  我要在这个队列中删除元素
 *  1。首先，用一个临时指针，记录下当前front指针指向的节点地址
 *  2.我把front指针指向当前指向的这个节点的后继节点
 *  3。把tmp指向的那个节点，删除
 *
 *  如果我们要判断这个链式结构的长度是不是为空
 *  仅仅只需要判断头尾节点的只是不是一致，就可以了
 */

