//
// Created by 沈航可 on 2019-08-23.
//
#include <cstdio>

#define n 5


/*
 * 树的概念
 *
 * 一个集合中，如果这个集合不为空的话，那么这个集合中一定有一个节点，是根节点，这个根节点，是所有其他节点的起源，
 *
 * 举个例子：
 *
 *                  爷爷
 *           |       |      |
 *        儿子_1   女儿_1  儿子_2
 *
 *        对于这个例子，爷爷就是祖先，对应于树来说，爷爷，就是那个根节点
 *
 * 度的概念：对于一个树中的节点来说，这个节点有几个孩子，他的度就是多少
 *
 *
 *
 *
 *
 * 二叉树的概念
 *
 * 二叉树的本质其实就是一个树，在这个树中，一个节点的孩子节点最多只可有有两个，可以为0，1，2，但是不能超过2。
 * 假如一个二叉树的节点中，有两个孩子，那么我们分别把这两个孩子叫做左孩子，和右孩子
 * 对于二叉树来说，如果左右孩子的位置可以互换，那么我们就说这个二叉树是一个无序二叉树，反之亦然
 * 对于一个二叉树中的节点来说，最大，只可有有2个子树
 * 二叉树其实就是一种特殊的树
 * 二叉树是一种数据结构，在这种结构中，一个节点，有两个子节点，对于每一个节点，只能够最大，有两个节点，不能够超过2个节点
 *
 *
 * 二叉树有一些数据，需要记一下：
 *
 *  我们默认，二叉树都是有序树，其左右节点，不可以互换
 *
 *
 *  特殊的二叉树：
 *  1。斜树
 *  2。满二叉树：所有有孩子节点的节点，他的孩子个数一定是2，也就是说，这个节点的度一定是2，并且，所有的叶子节点，都在同一层上。
 *  3。完全二叉树：如果我们给满二叉树的所有节点按照从左到右的顺序编号，如果一棵树，他的编号于这个满二叉树的编号顺序一致（这个树的节点数
 *  可以少于满二叉树），那么我们就把这个树叫做一个完全二叉树
 *
 *  完全二叉树有一个判断条件，如果一个节点的孩子节点，不是叶子节点的话，那么这个节点一定要有两个孩子节点，否则，这个树就一定不是二叉树
 *
 *  如何判断是一个树是一个完全二叉树：
 *  首先，我们要对这个树构建一个于这个树相对满二叉树，然后对这个满二叉树进行编号，同时，对我当前d 这个树进行编号，看这两个树的相同位置
 *  编号是不是一致，如果一致，就说明这个树是一个完全二叉树，如果不一致，就说明这个树不是一个完全二叉树。
 *
 *
 *
 *  如何把一个二叉树补全成对应的满二叉树：
 *  1。看这个给定的二叉树中的节点有没有子节点，如果有子节点的并且这个节点的子节点的个数为1，那么需要给这个节点加一个空的子节点
 *  2。观察给定的这个二叉树的深度是多少。如果给定的这个树经过第1步之后，有叶子节点的深度小于整颗树的深度，那么需要用空白的节点，作为当前
 *  这个叶子节点（那些深度没有达到整棵树深度的叶子节点）的子节点，循环这一步，直到所有的叶子节点，都在在同一深度下，并且，这个深度等于整棵树
 *  的深度。
 *
 *  每一层完全二叉树,如果那一层的几点全满的话,那么这一层的节点数是2^(n-1)
 *  如果一个二叉树,是一个完全二叉树的化,那么这个数的深度就是log2(n)+1
 *
 *  二叉树的存储结构
 *  有两种,一种是用数组保存的,(某种意义上来说,也可以叫做顺序存储的方式)
 *  第二种,是用链表来进行存储
 *
 *
 *  1.用数组来进行存储(默认从0开始)
 *  我们首先对一颗二叉树,以从上到下,从左到右的顺序,对一颗二叉树进行编码(编号的方式我们上节课讲过)
 *  我们就把这个编码作为存储数组的下标,把对应的节点,存储到数组中.
 *
 *  其中,对于完全二叉树来说,有这样一个规律
 *  我们可以通过一个节点的编码,计算出这个节点子节点的编号
 *
 *  对于一个完全二叉树来说,如果我们知道,一个节点的编码是N
 *  如果这个节点有子节点的话(如果这个树是一个完全二叉树,那么如果我们说有一个节点有子节点,那么这个节点必定有左子节点)
 *  那么左子节点的序号,一定是2*(n+1)-1
 *  对应的,如果有右子节点的话,那么右子节点的序号一定是2*(n+1)
 *  (这个是从0开始计数的)
 *
 *  如果是从1开始计数,那么左节点是2N,右节点是2N+1
 *
 *
 * 2.二叉树的链式存储
 * 之前我们讲顺序表的时候一个节点只保存一个指针,这个指针指向他的直接后继节点
 * 但是对于二叉树来说,因为一个节点的子节点(也可以理解为后继节点)有且最多只能有2个,对比与顺序链表来说,我们就增加一个指针
 * 换句来说,在一个节点里面保存两个指针,分别指向这个节点的左右孩子
 *
 * 二叉树的遍历
 * 一共有四种方式的来对一颗二叉树进行遍历
 * 1.先序遍历
 * 2.中序遍历
 * 3.后序遍历
 * 4.层序遍历
 *  在考试的时候,大概率会出一个这种题,给你一个以某种顺序遍历的节点序列,然后通过给定的这个序列和给定的遍历方式,还原出这个树
 *
 *  先序遍历
 *
 * */


//在线性表中，我们是这样定义的
/*
typedef struct PERSON{
    int age;
    int id;
    char name;
    struct PERSON* next;
};
 */

typedef struct PERSON{
    int age;
    int id;
    char name;
    struct PERSON* lchild;
    struct PERSON* rchild;
}Person,*PPerson;


/*
 * 递归的本质就是函数自己调用自己,在递归中,一定要设置出口
 * */

Person root;


//假如说我们现在有一颗树
//我们要使用这个函数去遍历整个二叉树,其中,参数的含义是当前正在遍历的节点
//如果是先序遍历的话,代码如下
/*
 * 这里记录一下先序遍历的节点序号
 *  ABDEHCFGI
 *
 * ABDF
 * */
void pre_walk(PPerson node){
    /*
     * 我们把获取节点信息的代码使用printf打印节点名字来代替
     * */
    if(node== nullptr){
        return;
    }
    printf("the current node name is: %c\n",node->name);
    pre_walk(node->lchild);
    pre_walk(node->rchild);
}

/*
 * 中序遍历与前序遍历不一样的地方在于
 * 他访问数据的步骤在遍历左节点和右节点之间
 *
 * DBHEAFCGI
 * */
void media_walk(PPerson node){
    if(node== nullptr){
        return;
    }
    media_walk(node->lchild);
    printf("the current node name is: %c\n",node->name);
    media_walk(node->rchild);
}

/*
 * 后序遍历
 * 所谓的后续遍历,其实跟前面说的前序遍历和中序遍历一样,只是访问本节点的顺序排在了访问
 * 左节点和右节点之后
 *
 * DHEBFIGCA
 * */
void rear_walk(PPerson node){
    if(node== nullptr){
        return;
    }
    media_walk(node->lchild);
    media_walk(node->rchild);
    printf("the current node name is: %c\n",node->name);
}

/*
 * 在考研的时候,会有这样的一种题型,
 * 给你一个二叉树的前序遍历顺序(或者后续遍历顺序),然后再给你一个中序遍历的顺序
 * 让你还原出二叉树来
 *
 * 比如,我现在给你一个二叉树的顺序
 * 前序顺序是:ABDEHCFGI
 *
 *
 * 中序顺序是:DBHEAFCGI
 * 后序顺序是:DHEBFIGCA
 *
 *
 * 把这个二叉树画出来
 *
 * 总结一下一些规律
 * 首先,出题的时候,一定会有一个中序遍历的顺序,因为如果只有前序遍历和后序遍历的话
 * 我们是无法还原出一个唯一的二叉树来,因为,我们只能够通过前序遍历和后序遍历的顺序得出
 * 哪一个节点是当前子树(或者说一颗完整的树)的根,而不能知道对于一个根来说,哪一部分是它的
 * 左子树,那一部分是她的右子树
 * 所以,出题的时候,一定会告诉你中序遍历的顺序
 * 然后会搭配一个前序遍历的顺序或者搭配一个后序遍历的顺序
 *
 * 1.在中序遍历中,找到根节点是哪一个之后,在这个顺序中,根节点所处位置的左边的那些节点,一定构成这个二叉树的左子树
 * 同理,右边的那些节点,一定构成这个二叉树的右子树
 *
 * 2.对于前序遍历来说,如果我们知道了一颗树包含那些节点,那么在这个节点序列中,第一个节点,一定是这个树(子树)的根节点
 *
 * 3.对于后序遍历来说,如果我们知道了一颗树包含那些节点,那么在这个节点序列中,最后一个节点,一定是这个树(子树)的根节点
 *
 * 因此,我们应对这种题型,有以下几个固定的解题步骤.
 * 1.我们先看给定的前序遍历或者后续遍历的顺序序列,找到当前这这个树的根是哪一个
 * 2.在中序遍历中,找到这个根节点,然后左边的字符序列就是这个树的左子树,右边的就是这个树的右子树
 * 3.将左(或者右)子树当成一个完整的树,重复第1,2步,直到能够把这个子树的所有结构推断出来
 *
 *
 * 哈弗曼树的构造
 * 对于哈夫曼树来说,在这个树中,有一些节点是带有权值的,我们通过这些权值,构造一棵树
 * 使得访问权值高的节点所需要走的路径是最少的
 * 访问权值低的节点,所需要走的路径相对要多一些
 *
 * 哈弗曼树的构造
 * 将所有含有权值的节点按照顺序进行排序,排序之后,遵循这样的步骤
 * 1.从这个序列中选择前面两个,构造一个空节点,将这权值低的节点作为这个空节点的左子节点,将权值高的节点作为这个子树的右子节点
 * 2.将构造出来的这个树作为一个整体(其权值就是这个树中所有带权的节点的总和),放回到权值序列中,进行重新排序
 * 3. 重复1,2 步
 *
 * 这个哈夫曼编码有什么用呢?
 *
 * 我们知道,在信息传输的时候,往往是需要进行信息的压缩的,怎么对这个信息进行压缩呢?
 * 就要用到哈夫曼编码
 *
 * 哈夫曼编码是基于这样的一个前提
 * 1.首先,信息的传输在信道中是以二进制进行传输的,也就是叫做数字信号
 * 2.假设我们要传输的信息是文本信息,这个文本信息中仅仅只包含字母,比如我们要传输的是hello world
 * 3.我们势必就要对这个字符串进行编码
 *
 * 怎么对这些文本信息进行编码最能够节省空间呢?
 * 换句话说,就是用最少的位数,来对信息进行编码?
 *
 * 哈夫曼编码是怎么做的.
 *
 * 哈夫曼编码假设我们对字母的使用率是不同的,比如说,在人类常用的文本中,通过统计,我们可以得知,
 * a 这个字母被使用到的概率是35%,b是20%.......
 *
 *
 * 相当于,这些字符都是一个节点,他们所出现的概率,就是这个节点的权值
 *
 *
 * */






//遍历开始
//walk(&root);








//如果我要表示树的话。假如，这个树有n个孩子
//类比于，上面这种方法，来定义树的结构
//这个机构表示的是一种族系的关系
//假如这个n是5，表示一个人最多可以生5个孩子
/*typedef struct PERSON{
    int age;
    int id;
    char name;
    //在线性表中，只需要一个指针，指向这个节点的后继节点，就可以了
    //但是在树的表示中，我们需要很多个指针，来表示这个节点的后继，是因为对于树这种结构来说，一个节点，会有很多个后续节点
    struct PERSON* children[n];
};*/

char list[]={'A','B','D','\0','\0','E','H','\0','\0','\0','C','F','\0','\0','G','\0','I','\0','\0'};
int index=0;
void construct(PPerson node){
    if(index>18){
        return;
    }
    if(list[index]='\0'){
        node= nullptr;
        return;
    }
    node=new Person;
    node->name=list[index];
    index++;
    construct(node->lchild);
    construct(node->rchild);
}



/*int main(){
    printf("123");
    return 0;
}*/

